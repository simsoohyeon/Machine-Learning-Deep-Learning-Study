## 15. RNN과 CNN을 사용한 시퀀스 처리
### 15.1 (1)
```
- 순환 신경망: 피드포워드 신경망과 유사하지만 뒤쪽으로 순환하는 연결이 있다는 점에서 다름
예를 들어 입력을 받아 출력을 만들고 자신에게도 출력을 보내는 뉴런 하나로 구성된 것

각 타임스템과 프레임마다 이 순환 뉴런은 입력 xt과 yt-1을 입력으로 받음
첫 번째 타임스텝은 이전 출력이 없으므로 일반적으로 0으로 설정
이 작은 네트워크를 시간을 축으로 하여 표현할 수 있는데 이를 네트워크를 펼쳤다 라고 함

<왼쪽>
단일 순환 뉴런이 입력을 받고 그 결과 출력을 생성함 이 출력은 타임스텝에서 같은 뉴런으로 피드백

<오른쪽>
시간의 흐름에 따라 동일한 뉴런이 여러 타임 스텝동안 펼쳐진 모습을 보여줌
각 뉴런은 이전 타임의 스텝을 다음 스텝의 입력으로 사용
입력과 출력이 모두 벡터가 됨 (뉴런이 하나일 때는 출력이 스칼라)
```
![image](https://github.com/simsoohyeon/Machine-Learning-Deep-Learning-Study/assets/127268889/ce7a6fbc-d340-4fbb-a16f-fce057054d1f)

### 15.1 (4)
```
- 메모리셀: 타임 스텝에 걸쳐서 어떤 상태를 보존하는 신경망의 구성 요소
RNN에서 메모리 셀은 시간을 따라 상태 정보를 유지하면서 작동, 연속적인 데이터 처리 가
```
### 15.1 (5)
```
- 입력과 출력 시퀀스
1. 시퀀스-투-시퀀스 네트워크
: 입력 시퀀스를 받아 출력 시퀀스를 생성하는 네트워크
2. 시퀀스-투-벡터 네트워크
: 입력 시퀀스를 받아 단일 벡터를 생성하는 네트워크
ex. 문장의 감성 분석에서 문장을 입력받아 감정 벡터를 출력
3. 벡터-투-시퀀스 네트워크
: 단일 벡터를 받아 출력 시퀀스 생성하는 네트워크
ex. 이미지 캡셔닝에서 이미지 벡터를 입력으로 받아 설명 문장을 생성
4. 인코더-디코더 네트워크
: 입력 시퀀스를 인코딩하여 중간 벡터 표현을 만들고, 이를 다시 디코딩하여 출력 시퀀스 생성
```
![image](https://github.com/simsoohyeon/Machine-Learning-Deep-Learning-Study/assets/127268889/731c7379-d97f-45c1-b451-311d15a713c1)

### 15.2 RNN 훈련
```
- BPTT backpropagation through time 전략
RNN 훈련 기법 - 타임 스텝으로 네트워크를 펼치고 보통의 역전파를 사용
```
### 15.3 시계열 예측하기 (1)
```
내일 버스와 열차에 탑승할 승객 수를 예측하는 모델 학습을 위한 데이터 로드 & 정제 과정

import pandas as pd
from pathlib import Path

path = Path("datasets/ridership/CTA_-_Ridership_-_Daily_Boarding_Totals.csv")
-> path 변수에 csv 파일의 경로 저장, 일일 승차 데이터가 포함된 CSV 파일

df = pd.read_csv(path, parse_dates=["service_date"])
-> parse=dates=["service_date"] 옵션 사용하여 열을 날짜 형식으로 

df.columns = ["date", "day_type", "bus", "rail", "total"]  # 짧은 이름
-> 데이터프레임의 열이름을 짧게 변경

df = df.sort_values("date").set_index("date")
-> date열을 기준으로 데이터프레임 정렬, date 열을 인덱스로 설정

df = df.drop("total", axis=1)  # total은 단순히 bus + rail이므로 필요 없음
-> total 열 삭제, bus와 rail의 합계이므로 모델 학습에 필요하지 않음

df = df.drop_duplicates()  # 중복 열 삭제 (2011-10과 2014-07)
-> 중복된 행 삭

아래 그림은 csv파일을 로드하고 열 이름 줄이고 날짜순으로 정렬하고 total열과 중복 행을 삭제
처음 몇 행만 확인, 일별 버스와 철도 이용 수
W-평일, A-토요일, U-공휴
```
![image](https://github.com/simsoohyeon/Machine-Learning-Deep-Learning-Study/assets/127268889/dea11c06-d69b-4078-8778-8ab679840827)

### 15.3 (2)
```
- 다변량 시계열: 여러 변수를 포함하면 시게열 데이터 
ex. 버스 승객 수와 열차 승객 수는 각각 하나의 변수
데이터를 사용하면 두 변수 간의 관계 분석

- 단변량 시계열: 단일 변수를 포함한 시계열 데이터
ex. 버스 승객 수만을 분석하는 경우가 단변량 시계열 분석
데이터를 사용하면 해당 변수의 시간적 변화를 분석 가능

- 주간 계열성: 데이터가 주기적으로 변동하는 패턴
ex. 주말과 평일에 따라 승객 수가 달라지는 패턴이 주간 계열성
이런 패턴을 파악하면 예측 모델의 정확도를 높임

- 단순 예측: 가장 최근의 관측값을 사용하여 미래를 예측
ex. 오늘의 승객 수를 내일의 승객 수로 예측하는 경우
단순하지만 종종 비교 기준으로 사용
```
```
import matplotlib.pyplot as plt

df["2019-03":"2019-05"].plot(grid=True, marker=".", figsize=(8, 3.5))
plt.show()

그래프는 2019.3부터 2019.5까지의 시카고 버스와 열차의 일일 승객 수를 보여줌
파란색 선은 버스 승객 수, 빨간색 선은 열차 승객 수
그래프에서 주간 계열성 확인 가능, 주말에는 승객 수가 적고 평일에는 증가하는 패
```
![image](https://github.com/simsoohyeon/Machine-Learning-Deep-Learning-Study/assets/127268889/6906f946-1714-41d0-b120-be8b0e60f39e)

### 15.3 (3)(4)
```
코드의 내용은 단순 예측 결과를 시각화하기 위해 버스와 열차에 대한 시계열 데이터를
차분 differencing 하여 정준선으로 그리는 과정임

차분: 시계열의 차이는 시간 t의 값에서 t-7의 값을 뺀 것, 이는 일주일 간의 차이
차분을 통해 데이터의 추세를 제거하고, 시계열의 계절성을 강조

diff_7 = df[["bus", "rail"]].diff(7)["2019-03":"2019-05"]

fig, axs = plt.subplots(2, 1, sharex=True, figsize=(8, 5))
-> fig는 전체 그림 객체, axs는 개별 서브플롯

df.plot(ax=axs[0], legend=False, marker=".")  # 원본 시계열
-> 원본 시계열 데이터를 첫 번째 서브플롯에 그림

df.shift(7).plot(ax=axs[0], grid=True, legend=False, linestyle=":")  # 지연된 시계열
-> 7일 지연된 시계열 데이터를 첫 번째 서브플롯에 그림

diff_7.plot(ax=axs[1], grid=True, marker=".")  # 7일 간의 차이
-> 7일 간의 차분 데이터를 두 번째 서브플롯에 그림

plt.show()


첫 번째 서브플롯: 원본 시계열(점)과 7일 지연된 시계열, 점선을 함께 그려 데이터 비교
주말과 평일에 따라 승객 수가 반복적으로 변화

두 번째 서브플롯: 7일 간의 차분 시계열을 그려, 시계열의 계절성을 강조
버스와 열차의 주간 패턴이 뚜렷, 평일과 주말의 승객 수 차이가 반복적
특정 기간에 급격한 변동은 예외적인 사건 (공휴일)으로 인해 발생
전체적으로 차분 시계열은 원본 시계열보다 변동성이 덜 큼, 이는 데이터의 계절성 강조

```
![image](https://github.com/simsoohyeon/Machine-Learning-Deep-Learning-Study/assets/127268889/518bdaa9-260d-4b62-9ba9-32433b782ee3)

### 15.3 (5)
```
- 자기상관 시계열: 시계열이 시간이 지연된 자기 자신과 상관 관게를 가질 때
ex. 5월 말 공휴일과 같은 이벤트가 시계열 데이터에 영향을 줌'

list(df.loc["2019-05-25":"2019-05-27"]["day_type"])
-> 특정 기간의 day_type확인 결과는 A,U,U

diff_7.abs().mean()
-> 평균 절댓값 오차 MAE 계산, 예측 모델이 실제 승객수와 비교하여 평균적으로 얼마가 차이나는지?
```
### 15.3 (6)
```
- 평균 절대 비율 오차 MAPE: 예측 오차를 타깃값으로 나누기
MAPE는 예측 오차를 타깃값으로 나누어 계산한 것으로, 예측의 상대적 정확도를 평가하는데 사용

targets = df[["bus", "rail"]]["2019-03":"2019-05"]

(diff_7 / targets).abs().mean()
-> diff_7은 앞서 계산한 7일 차분 값, abs() 함수는 절댓값 취해 음수를 제거, 평균 계산

결과: 버스는 약 8%, 열차는 약 8%
예측의 상대적 정확도를 평가하는데 사용되는 MAPE, 모두 10%이하로 나타나 예측 모델이 비교적 정확

```

### 15.3 (7)
```
연간 계졀성과 장기간 트렌트를 시각화하기 위한 12개월 이동 평균 그래프를 그리는 과정

연간 계절성의 의미: 데이터가 연도별과 주기적인 패턴을 보이는 현상
장기간 트렌드는 데이터가 오랜 기간 공안 어떻게 변화하는지 보여줌
12개월 이동 평균을 사용하여 이러한 트렌드와 계절성 시각


period = slice("2001", "2019")
-> 기간을 저장

df_monthly = df.resample("M").mean()  # 월 평균을 계산합니다.
-> 데이터를 월별로 리샘플링, 각 월의 평균값을 계산

rolling_average_12_months = df_monthly[period].rolling(window=12).mean()
-> df_monthly중 period 기간에 해당하는 데이터 선택, 12개월 이동 평균을 계산해 저장

fig, ax = plt.subplots(figsize=(8, 4))
df_monthly[period].plot(ax=ax, marker=".")
rolling_average_12_months.plot(ax=ax, grid=True, legend=False)
plt.show()

```
![image](https://github.com/simsoohyeon/Machine-Learning-Deep-Learning-Study/assets/127268889/08d97d30-196f-45e4-8f59-cbc0b58fb211)
```
위의 그래프는 12개월 차분 확

파란색 선: 버스 승객 수의 월별 평균값
빨간색 선: 열차 승객 수의 월별 평균값
파란색 굵은 선: 버스 승객 수의 12개월 이동 평균값
빨간색 굵은 선: 열차 승객 수의 12개월 이동 평균값

두 시계열 모두 연간 주기성을 보여줌, 여름과 겨울철의 생객 수 변화 패턴

장기간 트렌드: 버스 승객 수는 2000년대 중반까지 증가하다가 점차 감소하는 경향
열차 승객 수는 장기적으로 안정적인 증가 추세를 보이다가, 최근 몇 년간 일정한 수준 
```
### 15.3 (9)
```
- ARMA 모델
AR, 자기회귀: 과거의 값이 현재의 값에 영향을 미친다는 것을 전제로 함
과거의 값과 현재의 값 모델링, ex) 오늘의 주가가 어제의 주가에 영향

- MA, 이동평균: 이전의 시간 값을 이용하는 AR과 달리, 이전 시간의 백색 노이즈(이동 오차)를 이용해 모델링
직접 과거의 예측 오차와 현재 값 사이의 관계를 모델링, ex) 오늘의 기온이 예측 오차에 의해 영향

- 자기 회귀 이동 평균 모델 (ARMA)
AR과 MA를 함께 모형한 것으로, 지연된 값과 간단한 함수의 합을 이용하여 과거의 값 참조,
이동 평균을 더해 예측을 수정
ex) 주식 가격 예측에서 사용하면 과거의 주가와 예측 오차를 모두 고려해서 예측

- 자기 회귀 누적 이동 평균 (ARIMA)
시계열 데이터의 정상성, 꾸준히 흐른다는 것을 전제로 함
d번의 차분을 수행해 시계열을 정상 상태로 만들고 일반적인 ARMA모델을 적용
예측을 수행한 뒤 ARMA모델을 사용한 다음, 차분으로 뺐던 값을 다시 더함
ex) 트렌드가 있는 시계열 데이터를 정상 시계열로 변환한 후 예측

- 계절성 모델 Seasonal ARIMA, SARIMA 모델
ARIMA와 같은 방식으로 시계열을 모델링하지만 정확힌 동일한 ARIMA 방식을 사용해
주어진 빈도에 대한 계쩔을 추가한 모델링
ex) 계절적 변동이 있는 데이터에서 SARIMA모델을 사용하여 계절성을 고려한 예측

ARMA모델은 정상 시계열 데이터에 적합
ARIMA모델은 트렌드가 있는 데이터에
SARIMA모델은 계절적 패턴이 있는 데이터에 적합
```

### 15.3 (10)
```
- SARIMA모델
계절적 자기회귀 누적 이동 평균모델로, 시계열 데이터의 계절적 변동과 비계절적 변동을 모두 고려하여 예측
ARIMA 모델에 계절적 요소를 추가하여 확장한 모델

from statsmodels.tsa.arima.model import ARIMA


origin, today = "2019-01-01", "2019-05-31"


rail_series = df.loc[origin:today]["rail"].asfreq("D")


model = ARIMA(rail_series,
              order=(1, 0, 0),
              seasonal_order=(0, 1, 1, 7))


model = model.fit()


y_pred = model.forecast()  # 예측 결과: 427,758.6

```

























































